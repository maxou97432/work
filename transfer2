{
	"name": "KeyError",
	"message": "0",
	"stack": "---------------------------------------------------------------------------
KeyError                                  Traceback (most recent call last)
File n:\\uflumth\\indicateur_marche\\prix_m2\\my_cl_estim\\.venv\\Lib\\site-packages\\pandas\\core\\indexes\\base.py:3812, in Index.get_loc(self, key)
   3811 try:
-> 3812     return self._engine.get_loc(casted_key)
   3813 except KeyError as err:

File pandas/_libs/index.pyx:167, in pandas._libs.index.IndexEngine.get_loc()

File pandas/_libs/index.pyx:196, in pandas._libs.index.IndexEngine.get_loc()

File pandas/_libs/hashtable_class_helper.pxi:2606, in pandas._libs.hashtable.Int64HashTable.get_item()

File pandas/_libs/hashtable_class_helper.pxi:2630, in pandas._libs.hashtable.Int64HashTable.get_item()

KeyError: 0

The above exception was the direct cause of the following exception:

KeyError                                  Traceback (most recent call last)
Cell In[18], line 45
     43 #Raccordement
     44 first_idx = forecast[\"ds\"].idxmin()
---> 45 forecast_future.loc[first_idx,\"yhat\"] = (df_col[\"y\"].iloc[-1] + forecast_future.loc[first_idx, 'yhat']) / 2
     46 # Données réelles (pleines)
     47 fig.add_trace(go.Scatter(
     48     x=df_col[\"ds\"],
     49     y=df_col[\"y\"],
   (...)     52     line=dict(color=color, width=2)
     53 ))

File n:\\uflumth\\indicateur_marche\\prix_m2\\my_cl_estim\\.venv\\Lib\\site-packages\\pandas\\core\\indexing.py:1184, in _LocationIndexer.__getitem__(self, key)
   1182     key = tuple(com.apply_if_callable(x, self.obj) for x in key)
   1183     if self._is_scalar_access(key):
-> 1184         return self.obj._get_value(*key, takeable=self._takeable)
   1185     return self._getitem_tuple(key)
   1186 else:
   1187     # we by definition only have the 0th axis

File n:\\uflumth\\indicateur_marche\\prix_m2\\my_cl_estim\\.venv\\Lib\\site-packages\\pandas\\core\\frame.py:4232, in DataFrame._get_value(self, index, col, takeable)
   4226 engine = self.index._engine
   4228 if not isinstance(self.index, MultiIndex):
   4229     # CategoricalIndex: Trying to use the engine fastpath may give incorrect
   4230     #  results if our categories are integers that dont match our codes
   4231     # IntervalIndex: IntervalTree has no get_loc
-> 4232     row = self.index.get_loc(index)
   4233     return series._values[row]
   4235 # For MultiIndex going through engine effectively restricts us to
   4236 #  same-length tuples; see test_get_set_value_no_partial_indexing

File n:\\uflumth\\indicateur_marche\\prix_m2\\my_cl_estim\\.venv\\Lib\\site-packages\\pandas\\core\\indexes\\base.py:3819, in Index.get_loc(self, key)
   3814     if isinstance(casted_key, slice) or (
   3815         isinstance(casted_key, abc.Iterable)
   3816         and any(isinstance(x, slice) for x in casted_key)
   3817     ):
   3818         raise InvalidIndexError(key)
-> 3819     raise KeyError(key) from err
   3820 except TypeError:
   3821     # If we have a listlike key, _check_indexing_error will raise
   3822     #  InvalidIndexError. Otherwise we fall through and re-raise
   3823     #  the TypeError.
   3824     self._check_indexing_error(key)

KeyError: 0"
}
