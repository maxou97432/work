# Après avoir créé univers_complet et fusionné avec poids_global

# =============================================================================
# CORRECTION : Calculer I_3m et I_12m PAR TYPOLOGIE sur toute la série temporelle
# =============================================================================

typokeys = ["Ville", "BIEN_NEUF", "TYPE_BIEN", "NB_PIECES_RANGE"]

# Trier par typologie puis par date
univers_complet = univers_complet.sort_values(typokeys + ["Periode"])

# Calculer les indicatrices PAR TYPOLOGIE (pas par ville×periode)
univers_complet["I_3m"] = (
    univers_complet
    .groupby(typokeys, group_keys=False)["nb_transac"]
    .transform(lambda s: (s.rolling(window=3, min_periods=1).sum() > 0).astype(int))
)

univers_complet["I_12m"] = (
    univers_complet
    .groupby(typokeys, group_keys=False)["nb_transac"]
    .transform(lambda s: (s.rolling(window=12, min_periods=6).sum() > 0).astype(int))
)

print("✓ Indicatrices I_3m et I_12m calculées par typologie")

# =============================================================================
# Fonction d'agrégation SIMPLIFIÉE (les indicatrices sont déjà calculées)
# =============================================================================

def calcule_prix_pondere_ville_periode(g):
    """
    Agrège les prix au niveau Ville×Periode.
    Les indicatrices I_3m et I_12m sont déjà calculées en amont.
    """
    # Filtrer : ne garder que les typologies avec prix
    g = g[g["prix_moyen"].notna()].copy()
    
    if len(g) == 0:
        return pd.Series({
            "prix_moyen_pondere_dyn_3m": np.nan,
            "prix_moyen_pondere_dyn_12m": np.nan
        })
    
    # Calcul des poids actifs (indicatrices déjà présentes)
    g["poids_actif_3m"] = g["poids_relatif"] * g["I_3m"]
    g["poids_actif_12m"] = g["poids_relatif"] * g["I_12m"]
    
    total_poids_3m = g["poids_actif_3m"].sum()
    total_poids_12m = g["poids_actif_12m"].sum()
    
    # Prix pondérés
    if total_poids_3m > 0:
        prix_pondere_3m = np.average(g["prix_moyen"], weights=g["poids_actif_3m"])
    else:
        prix_pondere_3m = np.nan
    
    if total_poids_12m > 0:
        prix_pondere_12m = np.average(g["prix_moyen"], weights=g["poids_actif_12m"])
    else:
        prix_pondere_12m = np.nan
    
    return pd.Series({
        "prix_moyen_pondere_dyn_3m": prix_pondere_3m,
        "prix_moyen_pondere_dyn_12m": prix_pondere_12m
    })

# =============================================================================
# Agrégation par Ville × Periode (maintenant correct)
# =============================================================================

model_agg = (
    univers_complet
    .groupby(["Ville", "Periode"], as_index=False)
    .apply(calcule_prix_pondere_ville_periode)
    .reset_index(drop=True)
)

model_agg = model_agg.sort_values(["Ville", "Periode"])

print(f"✓ Agrégation terminée : {len(model_agg)} lignes")

# =============================================================================
# SUPPRIMER les rolling(1) qui ne servent à rien
# =============================================================================
# Ne PAS faire de rolling(1) supplémentaire, c'est inutile !
