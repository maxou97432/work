import pandas as pd
import numpy as np
import plotly.express as px
import os

# =============================================================================
# PRÉPARATION DES DONNÉES
# =============================================================================

top15 = ["PARIS", "MARSEILLE", "LYON", "LILLE", "RENNES", "TOULOUSE", "BORDEAUX", "NICE",
         "STRASBOURG", "NANTES", "MONTPELLIER", "TOULON", "REIMS", "SAINT-ETIENNE", "LE HAVRE"]

# Préparation base
base_ml2 = base_ml.copy()
base_ml2 = base_ml2.rename(columns={"ville_": "Ville"})
base_ml2["Ville"] = base_ml2["Ville"].astype(str).str.strip().str.upper()
base_ml2 = base_ml2[base_ml2["Ville"].isin(top15)]

# Conversion date et période mensuelle
base_ml2["DATE"] = pd.to_datetime(base_ml2["DATE"])
base_ml2["Periode"] = base_ml2["DATE"].dt.to_period("M").dt.to_timestamp()

print(f"✓ Données filtrées : {len(base_ml2):,} transactions sur {len(top15)} villes")

# =============================================================================
# AGRÉGATION MENSUELLE PAR TYPOLOGIE
# =============================================================================

keys = ["Ville", "BIEN_NEUF", "TYPE_BIEN", "NB_PIECES_RANGE", "Periode"]

univers_mensuel = (
    base_ml2
    .groupby(keys, dropna=False)
    .agg(
        nb_transac=("ID", "size"),
        prix_moyen=("Prix_m2", "mean"),
        prix_median=("Prix_m2", "median"),
        surface_moyenne=("NB_SURF_HAB", "mean")
    )
    .reset_index()
)

print(f"✓ Agrégation mensuelle : {len(univers_mensuel):,} lignes")

# =============================================================================
# VÉRIFICATION COHÉRENCE TYPE_BIEN / NB_PIECES_RANGE
# =============================================================================

univers_mensuel["PB"] = univers_mensuel["NB_PIECES_RANGE"].astype(str).str.strip().str[:3].str.upper()
univers_mensuel["TYPE_BIEN"] = univers_mensuel["TYPE_BIEN"].astype(str).str.strip().str.upper()
mask = univers_mensuel["TYPE_BIEN"] != univers_mensuel["PB"]
lignes_supprimees = mask.sum()
univers_mensuel = univers_mensuel.loc[~mask].drop(columns="PB")

print(f"✓ Vérification cohérence : {lignes_supprimees:,} lignes incohérentes supprimées")

# =============================================================================
# COMPLÉTION DU CALENDRIER MENSUEL PAR TYPOLOGIE
# =============================================================================

def complete_months(g):
    """
    Complète la série temporelle pour avoir tous les mois entre min et max.
    Les mois sans transaction ont nb_transac=0 et prix_moyen=NaN.
    """
    g = g.sort_values("Periode").set_index("Periode")
    idx = pd.date_range(g.index.min(), g.index.max(), freq="MS")
    g = g.reindex(idx)
    
    # Forward/backward fill pour les colonnes catégorielles
    for col in ["Ville", "BIEN_NEUF", "TYPE_BIEN", "NB_PIECES_RANGE"]:
        g[col] = g[col].ffill().bfill()
    
    # Remplir nb_transac avec 0, garder prix_moyen en NaN
    g["nb_transac"] = g["nb_transac"].fillna(0)
    g["prix_moyen"] = g["prix_moyen"]  # Garde les NaN
    
    return g.reset_index().rename(columns={"index": "Periode"})


univers_complet = (
    univers_mensuel
    .groupby(["Ville", "BIEN_NEUF", "TYPE_BIEN", "NB_PIECES_RANGE"], group_keys=False)
    .apply(complete_months)
)

print(f"✓ Calendrier complété : {len(univers_complet):,} lignes")

# =============================================================================
# CALCUL DES POIDS STRUCTURELS (LASPEYRES FIXES)
# =============================================================================

poids_global = (
    univers_mensuel
    .groupby(["Ville", "BIEN_NEUF", "TYPE_BIEN", "NB_PIECES_RANGE"], as_index=False)["nb_transac"]
    .sum()
    .rename(columns={"nb_transac": "poids_total"})
)

# Normalisation par ville (chaque ville = 100%)
poids_global["poids_relatif"] = (
    poids_global
    .groupby('Ville')["poids_total"]
    .transform(lambda x: x / x.sum())
)

print(f"✓ Poids structurels calculés : {len(poids_global):,} typologies")

# Fusion des poids avec univers_complet
univers_complet = univers_complet.merge(
    poids_global,
    on=["Ville", "BIEN_NEUF", "TYPE_BIEN", "NB_PIECES_RANGE"],
    how="left"
)

# =============================================================================
# CALCUL DES INDICATRICES I_3m ET I_12m PAR TYPOLOGIE
# (AVANT L'AGRÉGATION PAR VILLE×PERIODE)
# =============================================================================

print("\n=== CALCUL DES INDICATRICES D'ACTIVITÉ ===")

typokeys = ["Ville", "BIEN_NEUF", "TYPE_BIEN", "NB_PIECES_RANGE"]

# Tri crucial pour le rolling window
univers_complet = univers_complet.sort_values(typokeys + ["Periode"])

# Calcul des indicatrices PAR TYPOLOGIE sur toute la série temporelle
univers_complet["I_3m"] = (
    univers_complet
    .groupby(typokeys, group_keys=False)["nb_transac"]
    .transform(lambda s: (s.rolling(window=3, min_periods=1).sum() > 0).astype(int))
)

univers_complet["I_12m"] = (
    univers_complet
    .groupby(typokeys, group_keys=False)["nb_transac"]
    .transform(lambda s: (s.rolling(window=12, min_periods=6).sum() > 0).astype(int))
)

print("✓ Indicatrices I_3m et I_12m calculées par typologie")

# Diagnostic rapide
diag = univers_complet.groupby("Periode")[["I_3m", "I_12m"]].sum()
print(f"  Typologies actives moyennes par mois (3m)  : {diag['I_3m'].mean():.1f}")
print(f"  Typologies actives moyennes par mois (12m) : {diag['I_12m'].mean():.1f}")

# =============================================================================
# FONCTION D'AGRÉGATION SIMPLIFIÉE (INDICATRICES DÉJÀ CALCULÉES)
# =============================================================================

def calcule_prix_pondere_ville_periode(g):
    """
    Agrège les prix au niveau Ville×Periode avec pondération dynamique.
    Les indicatrices I_3m et I_12m sont déjà calculées en amont.
    """
    # Filtrer : ne garder que les typologies avec prix ce mois-ci
    g = g[g["prix_moyen"].notna()].copy()
    
    if len(g) == 0:
        return pd.Series({
            "prix_moyen_pondere_dyn_3m": np.nan,
            "prix_moyen_pondere_dyn_12m": np.nan,
            "nb_typo_actives_3m": 0,
            "nb_typo_actives_12m": 0
        })
    
    # Calcul des poids actifs (poids structurel × indicatrice)
    g["poids_actif_3m"] = g["poids_relatif"] * g["I_3m"]
    g["poids_actif_12m"] = g["poids_relatif"] * g["I_12m"]
    
    total_poids_3m = g["poids_actif_3m"].sum()
    total_poids_12m = g["poids_actif_12m"].sum()
    
    # Calcul des prix pondérés
    if total_poids_3m > 0:
        prix_pondere_3m = np.average(g["prix_moyen"], weights=g["poids_actif_3m"])
    else:
        prix_pondere_3m = np.nan
    
    if total_poids_12m > 0:
        prix_pondere_12m = np.average(g["prix_moyen"], weights=g["poids_actif_12m"])
    else:
        prix_pondere_12m = np.nan
    
    return pd.Series({
        "prix_moyen_pondere_dyn_3m": prix_pondere_3m,
        "prix_moyen_pondere_dyn_12m": prix_pondere_12m,
        "nb_typo_actives_3m": (g["I_3m"] == 1).sum(),
        "nb_typo_actives_12m": (g["I_12m"] == 1).sum()
    })


# =============================================================================
# AGRÉGATION PAR VILLE × PERIODE
# =============================================================================

print("\n=== AGRÉGATION PAR VILLE ET PERIODE ===")

model_agg = (
    univers_complet
    .groupby(["Ville", "Periode"], as_index=False)
    .apply(calcule_prix_pondere_ville_periode)
    .reset_index(drop=True)
)

model_agg = model_agg.sort_values(["Ville", "Periode"])

print(f"✓ Agrégation terminée : {len(model_agg):,} lignes")

# =============================================================================
# VÉRIFICATIONS ET DIAGNOSTICS
# =============================================================================

print("\n=== DIAGNOSTICS ===")

for ville in ["PARIS", "LYON", "MARSEILLE"]:
    df_ville = model_agg[model_agg["Ville"] == ville]
    
    prix_3m_valides = df_ville["prix_moyen_pondere_dyn_3m"].notna().sum()
    prix_12m_valides = df_ville["prix_moyen_pondere_dyn_12m"].notna().sum()
    
    if prix_3m_valides > 0 and prix_12m_valides > 0:
        divergence = (
            df_ville["prix_moyen_pondere_dyn_3m"] - 
            df_ville["prix_moyen_pondere_dyn_12m"]
        ).abs()
        
        print(f"\n{ville:15s}")
        print(f"  Prix 3m valides     : {prix_3m_valides}/{len(df_ville)}")
        print(f"  Prix 12m valides    : {prix_12m_valides}/{len(df_ville)}")
        print(f"  Divergence moyenne  : {divergence.mean():.0f} €")
        print(f"  Divergence max      : {divergence.max():.0f} €")

# =============================================================================
# BORNAGE TEMPOREL (OPTIONNEL)
# =============================================================================

model_agg = model_agg[model_agg["Periode"] < "2025-10-01"]

print(f"\n✓ Période finale : {model_agg['Periode'].min()} à {model_agg['Periode'].max()}")

# =============================================================================
# GÉNÉRATION DES GRAPHIQUES
# =============================================================================

print("\n=== GÉNÉRATION DES GRAPHIQUES ===")

output_dir = os.path.join(os.path.dirname(__file__), "results")
os.makedirs(output_dir, exist_ok=True)

for ville in model_agg["Ville"].unique():
    df_ville = model_agg[model_agg["Ville"] == ville].sort_values("Periode")

    fig = px.line(
        df_ville,
        x="Periode",
        y=["prix_moyen_pondere_dyn_3m", "prix_moyen_pondere_dyn_12m"],
        title=f"Évolution du prix au m² — {ville}",
        labels={"value": "Prix du m² (€)", "variable": "Indicateur", "Periode": "Date"},
        markers=True
    )
    
    fig.update_layout(
        title_x=0.5,
        plot_bgcolor="white",
        xaxis=dict(showgrid=True, gridcolor="#eee"),
        yaxis=dict(showgrid=True, gridcolor="#eee"),
        legend_title="Type de prix",
        height=500
    )
    
    # Sauvegarder en HTML
    output_path = os.path.join(output_dir, f"evolution_prix_{ville}.html")
    fig.write_html(output_path)
    print(f"  ✓ {ville:20s} -> {os.path.basename(output_path)}")

print(f"\n✓ Tous les graphiques sauvegardés dans : {output_dir}")
