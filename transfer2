#fonction de calcul pondéré par ville et mois
def calcule_prix_pondere_ville_periode(g):
    g = g.copy()
    g = g[g["prix_moyen"].notna()]  
    g["I_3m"] = (g["nb_transac"].rolling(3, min_periods=1).sum() > 0).astype(int)
    g["poids_actif_3m"] = g["poids_relatif"] * g["I_3m"]
    total_poids_3m = g["poids_actif_3m"].sum()

    g["I_12m"] = (g["nb_transac"].rolling(12, min_periods=6).sum() > 0).astype(int)
    g["poids_actif_12m"] = g["poids_relatif"] * g["I_12m"]
    total_poids_12m = g["poids_actif_12m"].sum()

    if total_poids_3m > 0:
        g["poids_dyn_3m"] = g["poids_actif_3m"] / total_poids_3m
        prix_pondere_3m = np.average(g["prix_moyen"], weights=g["poids_dyn_3m"])
    else:
        prix_pondere_3m = np.nan

    if total_poids_12m > 0:
        g["poids_dyn_12m"] = g["poids_actif_12m"] / total_poids_12m
        prix_pondere_12m = np.average(g["prix_moyen"], weights=g["poids_dyn_12m"])
    else:
        prix_pondere_12m = np.nan

    return pd.Series({"prix_moyen_pondere_dyn_3m": prix_pondere_3m, "prix_moyen_pondere_dyn_12m": prix_pondere_12m})

#agrégation principale
model_agg = (
    univers_complet
    .groupby(["Ville", "Periode"], as_index=False)
    .apply(calcule_prix_pondere_ville_periode)
    .reset_index(drop=True) 
)

# calculs glissants
model_agg = model_agg.sort_values(["Ville","Periode"])
model_agg["glissant_3m"] = (
    model_agg.groupby("Ville")["prix_moyen_pondere_dyn"]
    .transform(lambda s: s.rolling(3, min_periods=1).mean())
)
model_agg["glissant_12m"] = (
    model_agg.groupby("Ville")["prix_moyen_pondere_dyn"]
    .transform(lambda s: s.rolling(12, min_periods=3).mean())
)
