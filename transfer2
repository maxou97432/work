import numpy as np
import pandas as pd
import plotly.express as px

top15 = ["PARIS","MARSEILLE","LYON","LILLE","RENNES","TOULOUSE","BORDEAUX","NICE",
         "STRASBOURG","NANTES","MONTPELLIER","TOULON","REIMS","SAINT-ETIENNE","LE HAVRE"]

# Préparation villes
base_ml = base_ml.rename(columns={"ville_": "Ville"})
base_ml2 = base_ml.copy()
base_ml2["Ville"] = base_ml2["Ville"].astype(str).str.strip().str.upper()
base_ml2 = base_ml2[base_ml2["Ville"].isin(top15)]

# Période mensuelle
base_ml2["DATE"] = pd.to_datetime(base_ml2["DATE"], errors="raise")
base_ml2["Periode"] = base_ml2["DATE"].dt.to_period("M").dt.to_timestamp()

keys = ["Ville","BIEN_NEUF","TYPE_BIEN","NB_PIECES_RANGE","Periode"]

# Univers mensuel agrégé par typologie
univers_mensuel = (
    base_ml2
      .groupby(keys, dropna=False)
      .agg(
          nb_transac      = ("ID", "size"),
          prix_moyen      = ("Prix_m2", "mean"),
          prix_median     = ("Prix_m2", "median"),
          surface_moyenne = ("NB_SURF_HAB", "mean")
      )
      .reset_index()
)

# Cohérence TYPE_BIEN / NB_PIECES_RANGE (ton filtrage)
univers_mensuel["PB"] = univers_mensuel["NB_PIECES_RANGE"].astype(str).str.strip().str[:3].str.upper()
univers_mensuel["TYPE_BIEN"] = univers_mensuel["TYPE_BIEN"].astype(str).str.strip().str.upper()
mask = univers_mensuel["TYPE_BIEN"] != univers_mensuel["PB"]
univers_mensuel = univers_mensuel.loc[~mask].drop(columns="PB")

# Compléter le calendrier mensuel par typologie
def complete_months(g):
    g = g.sort_values("Periode").set_index("Periode")
    idx = pd.date_range(g.index.min(), g.index.max(), freq="MS")
    g = g.reindex(idx)
    for col in ["Ville","BIEN_NEUF","TYPE_BIEN","NB_PIECES_RANGE"]:
        g[col] = g[col].ffill().bfill()
    g["nb_transac"] = g["nb_transac"].fillna(0)
    g["prix_moyen"] = g["prix_moyen"]  # on garde NaN si pas de prix
    return g.reset_index().rename(columns={"index":"Periode"})

univers_complet = (
    univers_mensuel
      .groupby(["Ville","BIEN_NEUF","TYPE_BIEN","NB_PIECES_RANGE"], group_keys=False)
      .apply(complete_months)
)

# Poids globaux par typologie (structures fixées par Ville)
poids_global = (
    univers_mensuel
      .groupby(["Ville","BIEN_NEUF","TYPE_BIEN","NB_PIECES_RANGE"], as_index=False)["nb_transac"]
      .sum()
      .rename(columns={"nb_transac": "poids_total"})
)
poids_global["poids_relatif"] = poids_global.groupby('Ville')["poids_total"].transform(lambda x: x/x.sum())

univers_complet = univers_complet.merge(
    poids_global,
    on=["Ville","BIEN_NEUF","TYPE_BIEN","NB_PIECES_RANGE"],
    how="left"
)

# >>>>>>> CORRECTION CLE : indicatrices TEMPORELLES par typologie <<<<<<<
typokeys = ["Ville","BIEN_NEUF","TYPE_BIEN","NB_PIECES_RANGE"]
univers_complet = univers_complet.sort_values(typokeys + ["Periode"])

univers_complet["I_3m"] = (
    univers_complet
      .groupby(typokeys, group_keys=False)["nb_transac"]
      .transform(lambda s: (s.rolling(3,  min_periods=1).sum() > 0).astype(int))
)

univers_complet["I_12m"] = (
    univers_complet
      .groupby(typokeys, group_keys=False)["nb_transac"]
      .transform(lambda s: (s.rolling(12, min_periods=6).sum() > 0).astype(int))
)

# Agrégateur Ville x Periode utilisant les indicatrices pré-calculées (PAS de rolling ici)
def calcule_prix_pondere_ville_periode(g):
    have_price = g["prix_moyen"].notna()

    w3  = (g["poids_relatif"] * g["I_3m"]).where(have_price, 0.0)
    w12 = (g["poids_relatif"] * g["I_12m"]).where(have_price, 0.0)

    tot3  = w3.sum()
    tot12 = w12.sum()

    prix_pondere_3m  = np.average(g.loc[have_price, "prix_moyen"], weights=w3.loc[have_price])  if tot3  > 0 else np.nan
    prix_pondere_12m = np.average(g.loc[have_price, "prix_moyen"], weights=w12.loc[have_price]) if tot12 > 0 else np.nan

    return pd.Series({
        "prix_moyen_pondere_dyn_3m":  prix_pondere_3m,
        "prix_moyen_pondere_dyn_12m": prix_pondere_12m
    })

# Agrégation principale par Ville x Periode (OK maintenant)
model_agg = (
    univers_complet
      .groupby(["Ville", "Periode"], as_index=False)
      .apply(calcule_prix_pondere_ville_periode)
      .reset_index(drop=True)
      .sort_values(["Ville","Periode"])
)

# (Option) bornage temporel
model_agg = model_agg[model_agg["Periode"] < "2025-10-01"]

# Plot : on trace directement les deux séries dynamiques (plus cohérent)
for ville in model_agg["Ville"].unique():
    df_ville = model_agg[model_agg["Ville"] == ville].sort_values("Periode")
    if df_ville[["prix_moyen_pondere_dyn_3m","prix_moyen_pondere_dyn_12m"]].notna().sum().sum() == 0:
        print(f"Aucune donnée exploitable pour {ville}")
        continue
    fig = px.line(
        df_ville,
        x="Periode",
        y=["prix_moyen_pondere_dyn_3m", "prix_moyen_pondere_dyn_12m"],
        title=f"Évolution du prix au m² — {ville}",
        labels={"value": "Prix du m² (€)", "variable": "Indicateur", "Periode": "Date"},
        markers=True
    )
    fig.update_layout(
        title_x=0.5,
        plot_bgcolor="white",
        xaxis=dict(showgrid=True, gridcolor="#eee"),
        yaxis=dict(showgrid=True, gridcolor="#eee"),
        legend_title="Type de prix",
        height=500
    )
    fig.show()
