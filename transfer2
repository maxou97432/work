top15 = ["PARIS", "MARSEILLE", "LYON", "LILLE", "RENNES", " TOULOUSE", "BORDEAUX", "NICE", "STRASBOURG", "NANTES", "MONTPELLIER",
         "TOULON", "REIMS", "SAINT-ETIENNE", "LE HAVRE"]
base_ml2 = base_ml2[base_ml2["Ville"].isin(top15)]

dims = ["Ville", "BIEN_NEUF", "TYPE_BIEN", "NB_PIECES_RANGE"]


univers = (
    base_ml2.groupby(dims, dropna=False)
      .agg(
          nb_transac = ("ID", "size"),
          prix_median = ("Prix_m2", "median"),
          prix_moyen = ("Prix_m2", "mean"),
          surface_moyenne = ("NB_SURF_HAB", "mean")

      )
      .reset_index()
)

grille = (
    pd.MultiIndex.from_product(
        [base_ml2["Ville"].unique(),
         base_ml2["BIEN_NEUF"].unique(),
         base_ml2["TYPE_BIEN"].unique(),
         base_ml2["NB_PIECES_RANGE"].unique()],
        names=dims
    ).to_frame(index=False)
)


univers_complet_ville = grille.merge(univers, on=dims, how="left").sort_values(dims)


univers_complet_ville["nb_transac"] = univers_complet_ville["nb_transac"].fillna(0).astype(int)

univers_complet_ville["PB"] = (
    univers_complet_ville["NB_PIECES_RANGE"]
    .astype(str)
    .str.strip()
    .str[:3]
    .str.upper()
)
univers_complet_ville["TYPE_BIEN"] = univers_complet_ville["TYPE_BIEN"].astype(str).str.strip().str.upper()


mask = univers_complet_ville["TYPE_BIEN"] != univers_complet_ville["PB"]

univers_complet_ville = univers_complet_ville.loc[~mask].copy()
univers_complet_ville = univers_complet_ville.drop(columns=["PB"])
univers_complet_ville["Repartition (%)"] = (univers_complet_ville["nb_transac"] / univers_complet_ville.groupby("Ville")["nb_transac"].transform(sum)) * 100

univers_complet_ville

top15 = ["PARIS","MARSEILLE","LYON","LILLE","RENNES","TOULOUSE","BORDEAUX","NICE",
         "STRASBOURG","NANTES","MONTPELLIER","TOULON","REIMS","SAINT-ETIENNE","LE HAVRE"]
base_ml2 = base_ml2.rename(columns={"ville_":"Ville"})
base_ml2 = base_ml2.copy()
base_ml2["Ville"] = base_ml2["Ville"].astype(str).str.strip().str.upper()
base_ml2 = base_ml2[base_ml2["Ville"].isin(top15)]


base_ml2["DATE"] = pd.to_datetime(base_ml2["DATE"])
base_ml2["Periode"] = base_ml2["DATE"].dt.to_period("M").dt.to_timestamp()


keys = ["Ville","BIEN_NEUF","TYPE_BIEN","NB_PIECES_RANGE","Periode"]

univers_mensuel = (
    base_ml2
      .groupby(keys, dropna=False)
      .agg(
          nb_transac     = ("ID", "size"),
          prix_moyen     = ("Prix_m2", "mean"),
          prix_median    = ("Prix_m2", "median"),
          surface_moyenne= ("NB_SURF_HAB", "mean")
      )
      .reset_index()
)


univers_mensuel["PB"] = univers_mensuel["NB_PIECES_RANGE"].astype(str).str.strip().str[:3].str.upper()
univers_mensuel["TYPE_BIEN"] = univers_mensuel["TYPE_BIEN"].astype(str).str.strip().str.upper()
mask = univers_mensuel["TYPE_BIEN"] != univers_mensuel["PB"]
univers_mensuel = univers_mensuel.loc[~mask].drop(columns="PB")


def complete_months(g):
    g = g.sort_values("Periode").set_index("Periode")
    idx = pd.date_range(g.index.min(), g.index.max(), freq="MS")
    g = g.reindex(idx)
    for col in ["Ville","BIEN_NEUF","TYPE_BIEN","NB_PIECES_RANGE"]:
        g[col] = g[col].ffill().bfill()
    g["nb_transac"] = g["nb_transac"].fillna(0)
    return g.reset_index().rename(columns={"index":"Periode"})

univers_complet = (
    univers_mensuel
      .groupby(["Ville","BIEN_NEUF","TYPE_BIEN","NB_PIECES_RANGE"], group_keys=False)
      .apply(complete_months)
)
poids_global = (
    univers_mensuel.groupby(["Ville","BIEN_NEUF","TYPE_BIEN","NB_PIECES_RANGE"], as_index = False)["nb_transac"].sum().rename(columns={"nb_transac":"poids_total"}))
poids_global["poids_relatif"] = poids_global.groupby('Ville')["poids_total"].transform(lambda x : x/x.sum())

univers_complet = univers_complet.merge(
    poids_global,
    on = ["Ville","BIEN_NEUF","TYPE_BIEN","NB_PIECES_RANGE"],
    how = "left"
)

def rolling_weighted_global(g):
    g = g.sort_values("Periode").copy()

    g["poids_fix"] = g["poids_relatif"].fillna(0)

    def wavg(series):
        poids_loc = g.loc[series.index, "poids_fix"]
        valid = poids_loc > 0
        if valid.sum() == 0:
            return np.nan
        return np.average(series[valid],weights = poids_loc[valid])
    
    
    g["prix_moyen_glissant_pondere_12m"] = (
        g["prix_moyen"].rolling(window = 12, min_periods = 12).apply(wavg, raw = False)
    )
    g["prix_moyen_glissant_pondere_3m"] = (
        g["prix_moyen"].rolling(window = 3, min_periods = 1).apply(wavg, raw = False)
    )
    
    return g

univers_glissant = (
    univers_complet
      .groupby(["Ville","BIEN_NEUF","TYPE_BIEN","NB_PIECES_RANGE"], group_keys=False)
      .apply(rolling_weighted_global)
)


resultat = univers_glissant[
    ["Periode","Ville","BIEN_NEUF","TYPE_BIEN","NB_PIECES_RANGE",
     "prix_moyen","nb_transac","prix_moyen_glissant_pondere_12m"]
].sort_values(["Ville","BIEN_NEUF","TYPE_BIEN","NB_PIECES_RANGE","Periode"])

resultat



df = resultat.copy()
df["Periode"] = pd.to_datetime(df["Periode"])
df["Ville"]   = df["Ville"].str.strip().str.upper()

city_month = (
    df.assign(prod=lambda x: x["prix_moyen"] * x["nb_transac"])
      .groupby(["Ville","Periode"], as_index=False)
      .agg(nb_transac_total=("nb_transac","sum"),
           sum_prod=("prod","sum"))
)
city_month["prix_moyen_pondere_ville"] = (
    city_month["sum_prod"] / city_month["nb_transac_total"].where(city_month["nb_transac_total"]>0)
)

def complete_city(g):
    g = g.sort_values("Periode").set_index("Periode")
    idx = pd.date_range(g.index.min(), g.index.max(), freq="MS")
    g = g.reindex(idx)
    g["Ville"] = g["Ville"].ffill().bfill()
    g["nb_transac_total"] = g["nb_transac_total"].fillna(0)
    g["sum_prod"] = g["sum_prod"].fillna(0)

    g["prix_moyen_pondere_ville"] = g["sum_prod"] / g["nb_transac_total"].where(g["nb_transac_total"]>0)
    return g.reset_index().rename(columns={"index":"Periode"})

city_month = (
    city_month.groupby("Ville", group_keys=False).apply(complete_city)
)

def rolling_city(g):
    g = g.sort_values("Periode")
    num_12m = g["sum_prod"].rolling(12, min_periods=12).sum()
    den_12m = g["nb_transac_total"].rolling(12, min_periods=12).sum()
    g["prix_glissant_pondere_12m_ville"] = num_12m / den_12m.where(den_12m>0)
    num_3m = g["sum_prod"].rolling(3, min_periods=1).sum()
    den_3m = g["nb_transac_total"].rolling(3, min_periods=1).sum()
    g["prix_glissant_pondere_3m_ville"] = num_3m / den_3m.where(den_3m>0)
    return g

city_month = city_month.groupby("Ville", group_keys=False).apply(rolling_city)


model_agg = city_month.rename(columns={
    "Periode":"DATE",
    "prix_moyen_pondere_ville":"Prix_m2_moyen_pondere",
    "prix_glissant_pondere_12m_ville":"Glissant_pondere_12m",
    "prix_glissant_pondere_3m_ville":"Glissant_pondere_3m"

})

import plotly.express as px
import pandas as pd

# Harmonisation des noms de colonnes
model_agg = city_month.rename(columns={
    "Periode": "DATE",
    "prix_moyen_pondere_ville": "Prix_m2_moyen_pondere",
    "prix_glissant_pondere_12m_ville": "Glissant_pondere_12m",
    "prix_glissant_pondere_3m_ville" : "Glissant_pondere_3m"
})

model_agg2 = model_agg.drop(columns=["Prix_m2_moyen_ponderere","nb_transac_total","sum_prod"], errors="ignore")


model_agg2["DATE"] = pd.to_datetime(model_agg2["DATE"], errors="coerce")
merge["DATE"] = pd.to_datetime(merge["DATE"], errors="coerce")

# Fusion des deux tables sur Ville + DATE
fusion = pd.merge(
    model_agg2,
    merge,
    on=["Ville", "DATE"],
    how="outer",
    suffixes = ("_univ","_ext")
)
fusion = fusion.rename(columns={"Glissant_pondere_12m":"Prix moyen glissant 12 mois - Univ Elem", 
                                "Glissant_pondere_3m":"Prix moyen glissant 3 mois - Univ Elem"})
# Boucle pour tracer un graphique par ville
for ville in fusion["Ville"].dropna().unique():
    df_ville = fusion[fusion["Ville"] == ville].sort_values("DATE")

    # Liste des colonnes numériques à tracer
    colonnes_a_tracer = ["Prix moyen glissant 12 mois - Univ Elem", "Prix moyen glissant 3 mois - Univ Elem",
                         "Prix moyen glissant 12 mois - LPI/IAD","Prix moyen glissant 12 mois - CL"]

    fig = px.line(
        df_ville,
        x="DATE",
        y=colonnes_a_tracer,
        title=f"Évolution du prix au m² — {ville}",
        labels={"value": "Prix du m² (€)", "variable": "Indicateur", "DATE": "Date"},
        markers=True
    )

    fig.update_layout(
        title_x=0.5,
        plot_bgcolor="white",
        xaxis=dict(showgrid=True, gridcolor="#eee"),
        yaxis=dict(showgrid=True, gridcolor="#eee"),
        legend_title="Type de prix",
        height=600
    )
    fig.update_traces(opacity=0.7)
    fig.show()
