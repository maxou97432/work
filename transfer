<class 'pandas.core.frame.DataFrame'>
RangeIndex: 11152019 entries, 0 to 11152018
Data columns (total 90 columns):
 #   Column                          Dtype         
---  ------                          -----         
 0   CD_OP                           object        
 1   CD_NATUR_OP                     object        
 2   MT_ENCOURS                      float32       
 3   CD_STATUT                       object        
 4   NB_SURF_HAB                     float64       
 5   NB_SURF_CREE                    float32       
 6   NB_PIECES                       float64       
 7   NB_SURF_TER                     float64       
 8   MT_VAL                          float32       
 9   VALEUR_FONCIERE                 float32       
 10  MT_REVENU_ANN                   float32       
 11  AGE_EMP1                        float32       
 12  AGE_EMP2                        float32       
 13  CD_CSP_EMP1                     object        
 14  CD_CSP_EMP2                     object        
 15  CD_ETAT_CIVIL                   float32       
 16  nb_enf_charge                   float32       
 17  DT_MEP                          datetime64[ns]
 18  DT_RECEP                        datetime64[ns]
 19  MT_OPE                          float32       
 20  TYPE_BIEN                       object        
 21  RNVP_SCORING                    object        
 22  RNVP_ADRESSE2                   object        
 23  RNVP_ADRESSE3                   object        
 24  RNVP_NUM_VOIE                   object        
 25  ADRESSE_SUFFIXE                 object        
 26  ADRESSE4                        object        
 27  RNVP_ADRESSE5                   object        
 28  RNVP_ADRESSE6                   object        
 29  RNVP_GEO_PG                     object        
 30  LONGITUDE                       float32       
 31  LATITUDE                        float32       
 32  CD_INDI_EMP1                    object        
 33  CD_INDI_EMP2                    object        
 34  MT_POSTCOUT_TVX                 float64       
 35  OP_MEP                          float64       
 36  DEPT                            object        
 37  RNVP_VILLE                      object        
 38  CODE_POSTAL_Init                object        
 39  LIBELLE_DEPT                    object        
 40  adresse_suff                    object        
 41  cle_voie                        object        
 42  KEY_LONG_LAT                    object        
 43  KEY_LONG_LAT3                   object        
 44  KEY_LONG_LAT1                   object        
 45  CLE_INTEROP_ADR                 object        
 46  verif_adresse                   object        
 47  ADRESSEM                        object        
 48  id_                             float64       
 49  idx_                            object        
 50  CODE_POSTAL                     object        
 51  ville_                          object        
 52  adr0                            object        
 53  adr_                            object        
 54  num_voie_                       object        
 55  type_voie_                      object        
 56  adr_bis                         object        
 57  dept_                           object        
 58  prenom_voie_                    object        
 59  NUM_VOIE_SUFF                   object        
 60  SOURCE                          object        
 61  DATE_MUTATION                   datetime64[ns]
 62  ID_MUTATION                     object        
 63  DEPT_Corse_2A_2B                object        
 64  Prix_m2                         float64       
 65  Prix_piece                      float64       
 66  nb_m2_by_piece                  float64       
 67  TVX_prix_m2                     float64       
 68  DATE                            datetime64[ns]
 69  YEAR                            int64         
 70  CD_INDI_MIN                     object        
 71  CD_INDI_MAX                     object        
 72  AGE_EMP_MIN                     float32       
 73  AGE_EMP_MAX                     float32       
 74  CD_CSP_EMP_MIN                  object        
 75  CD_CSP_EMP_MAX                  object        
 76  ID                              int64         
 77  ID_DEDOUB                       object        
 78  SCORE_COMPLETUDE                int32         
 79  ID_PARCELLE                     object        
 80  MAX_surface_reelle_bati_unique  float64       
 81  NOMBRE_LOTS                     float64       
 82  nb_PARCELLES                    float64       
 83  Habitation_unique               float64       
 84  Dependance_unique               float64       
 85  Terrain_unique                  float64       
 86  nb_TYPE_LOCAL_Maison            float64       
 87  nb_TYPE_LOCAL_Appartement       float64       
 88  nb_TYPE_LOCAL_Dépendance        float64       
 89  NATURE_MUTATION                 object        

import pandas as pd
import numpy as np
from typing import Literal, Optional, Sequence, List

GeoLevel = Literal["city", "department"]

# ---------------------------------------------------------
# 1️⃣ Fonctions utilitaires pour normaliser la base
# ---------------------------------------------------------

def _to_anciennete(x) -> str:
    if isinstance(x, str):
        s = x.strip().lower()
        if s in {"neuf","neuve","vefa","v.e.f.a"}:
            return "neuf"
        if s in {"ancien","ancienne","existant"}:
            return "ancien"
    if isinstance(x, (bool, np.bool_)):
        return "neuf" if x else "ancien"
    return "ancien"

def _to_type(x) -> str:
    if x is None:
        return "appartement"
    s = str(x).strip().lower()
    if "mais" in s:
        return "maison"
    return "appartement"

def _bin_pieces(property_type: str, rooms: Optional[float]) -> str:
    if pd.isna(rooms):
        return "NA"
    r = int(rooms)
    if property_type == "appartement":
        if r <= 2:
            return "[1–2]"
        elif r <= 4:
            return "[3–4]"
        else:
            return "5+"
    else:
        return "<=4" if r <= 4 else ">=5"

def prepare_base(df: pd.DataFrame, geo_level: GeoLevel = "department") -> pd.DataFrame:
    """Prépare la base en homogénéisant les noms et types de colonnes"""
    d = df.copy()

    # --- Colonnes date / prix / surface ---
    if "date" not in d.columns:
        for c in ["DATE","Date","date_transaction","dt"]:
            if c in d.columns:
                d["date"] = d[c]; break
    d["date"] = pd.to_datetime(d.get("date"), errors="coerce")

    if "price" not in d.columns:
        for c in ["PRICE","prix","montant","amount"]:
            if c in d.columns:
                d["price"] = pd.to_numeric(d[c], errors="coerce"); break

    if "surface_m2" not in d.columns:
        for c in ["SURFACE_M2","surface","surface_habitable","surface_carrez"]:
            if c in d.columns:
                d["surface_m2"] = pd.to_numeric(d[c], errors="coerce"); break

    # --- Zone géographique ---
    if geo_level == "city":
        if "city" not in d.columns:
            for c in ["CITY","commune","ville","nom_commune"]:
                if c in d.columns:
                    d["city"] = d[c]; break
        d["zone"] = d["city"].astype(str)
    else:
        if "department" not in d.columns:
            for c in ["DEPARTMENT","DEPARTEMENT","dept","code_departement"]:
                if c in d.columns:
                    d["department"] = d[c]; break
        d["zone"] = d["department"].astype(str)

    # --- Type / ancienneté / nb pièces ---
    if "property_type" not in d.columns:
        for c in ["TYPE","property","type_local"]:
            if c in d.columns:
                d["property_type"] = d[c]; break
    d["property_type"] = d["property_type"].map(_to_type)

    if "is_new" not in d.columns:
        for c in ["IS_NEW","neuf","anciennete","new"]:
            if c in d.columns:
                d["is_new"] = d[c]; break
    d["anciennete"] = d["is_new"].map(_to_anciennete)

    if "rooms" not in d.columns:
        for c in ["ROOMS","nb_pieces","pieces","nombre_pieces"]:
            if c in d.columns:
                d["rooms"] = d[c]; break
    d["bin_pieces"] = [_bin_pieces(t, r) for t, r in zip(d["property_type"], d["rooms"])]

    # --- Prix au m² ---
    d["ppm2"] = d["price"] / d["surface_m2"]
    return d

# ---------------------------------------------------------
# 2️⃣ Construction de la grille complète des univers
# ---------------------------------------------------------

def build_universe_grid(zones, include_periods=None) -> pd.DataFrame:
    """Construit le tableau exhaustif de toutes les combinaisons possibles"""
    zones = list(pd.Index(zones).astype(str).unique())
    anc = ["neuf","ancien"]
    app_bins = ["[1–2]","[3–4]","5+"]
    maison_bins = ["<=4",">=5"]

    def _mk(property_type: str, bins: List[str]) -> pd.DataFrame:
        return pd.MultiIndex.from_product(
            [zones, anc, [property_type], bins],
            names=["zone","anciennete","property_type","bin_pieces"]
        ).to_frame(index=False)

    if include_periods is None:
        grid = pd.concat([_mk("appartement", app_bins), _mk("maison", maison_bins)], ignore_index=True)
        return grid
    else:
        periods = list(pd.Index(include_periods).astype("datetime64[ns]").unique())
        grid_app = pd.MultiIndex.from_product(
            [periods, zones, anc, ["appartement"], app_bins],
            names=["periode","zone","anciennete","property_type","bin_pieces"]
        ).to_frame(index=False)
        grid_maison = pd.MultiIndex.from_product(
            [periods, zones, anc, ["maison"], maison_bins],
            names=["periode","zone","anciennete","property_type","bin_pieces"]
        ).to_frame(index=False)
        return pd.concat([grid_app, grid_maison], ignore_index=True)

# ---------------------------------------------------------
# 3️⃣ Calcul des métriques et reindexation sur la grille complète
# ---------------------------------------------------------

def compute_universe_table(
    df: pd.DataFrame,
    geo_level: GeoLevel = "department",
    period: Optional[Literal["M","Q","A"]] = "Q",
    min_tx: Optional[int] = None,
    keep_metrics: Optional[Sequence[str]] = ("n_tx","median_ppm2","p25_ppm2","p75_ppm2","mean_ppm2_trim"),
) -> pd.DataFrame:
    """Calcule les indicateurs par univers et renvoie le tableau complet"""
    d = prepare_base(df, geo_level=geo_level).copy()

    # --- Périodes ---
    if period is not None:
        d["periode"] = d["date"].dt.to_period(period).dt.to_timestamp()
        group_cols = ["periode","zone","anciennete","property_type","bin_pieces"]
    else:
        group_cols = ["zone","anciennete","property_type","bin_pieces"]

    # --- Moyenne tronquée ---
    def _trimmed_mean(x: pd.Series, p: float = 0.05):
        if len(x) == 0:
            return np.nan
        lo, hi = x.quantile([p, 1-p])
        return x[(x>=lo) & (x<=hi)].mean()

    gb = d.groupby(group_cols, observed=True)
    agg = gb.agg(
        n_tx=("price","size"),
        median_ppm2=("ppm2","median"),
        p25_ppm2=("ppm2", lambda s: s.quantile(0.25)),
        p75_ppm2=("ppm2", lambda s: s.quantile(0.75)),
        mean_ppm2_trim=("ppm2", _trimmed_mean),
    ).reset_index()

    # --- Grille exhaustive ---
    if period is not None:
        periods = d["periode"].dropna().sort_values().unique()
        zones = d["zone"].dropna().astype(str).unique()
        grid = build_universe_grid(zones, include_periods=periods)
        key = ["periode","zone","anciennete","property_type","bin_pieces"]
    else:
        zones = d["zone"].dropna().astype(str).unique()
        grid = build_universe_grid(zones, include_periods=None)
        key = ["zone","anciennete","property_type","bin_pieces"]

    out = grid.merge(agg, on=key, how="left")

    # --- Application du seuil de volume ---
    if min_tx is not None and "n_tx" in out.columns:
        mask = out["n_tx"] < min_tx
        for col in ["median_ppm2","p25_ppm2","p75_ppm2","mean_ppm2_trim"]:
            if col in out.columns:
                out.loc[mask, col] = np.nan

    out = out.sort_values(key)

    if keep_metrics is not None:
        cols = key + [c for c in keep_metrics if c in out.columns]
        out = out[cols]

    return out


# Ajout de la colonne région
df['region'] = df['departement'].astype(str).map(dep_to_region)
