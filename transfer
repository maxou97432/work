{
	"name": "ValueError",
	"message": "unconverted data remains when parsing with format \"%Y\": \"-01-01\", at position 0. You might want to try:
    - passing `format` if your strings have a consistent format;
    - passing `format='ISO8601'` if your strings are all ISO8601 but not necessarily in exactly the same format;
    - passing `format='mixed'`, and the format will be inferred for each element individually. You might want to use `dayfirst` alongside this.",
	"stack": "---------------------------------------------------------------------------
ValueError                                Traceback (most recent call last)
Cell In[84], line 72
     67 df_ti_paris['Year'] = pd.to_datetime(df_ti_paris['Year'].astype(str), format='%Y')
     68 df_ti_paris.sort_values(by='Year')    
---> 72 df_ti_paris['Year'] = pd.to_datetime(df_ti_paris['Year'].astype(str), format='%Y')
     73 df_ti_paris[\"Year\"] = df_ti_paris[\"Year\"].dt.year
     74 df_ti_paris = calcul_indice(df_ti_paris, base_annee = 2012, base_indice= 100)

File ~\\AppData\\Roaming\\Python\\Python311\\site-packages\\pandas\\core\\tools\\datetimes.py:1072, in to_datetime(arg, errors, dayfirst, yearfirst, utc, format, exact, unit, infer_datetime_format, origin, cache)
   1070         result = arg.map(cache_array)
   1071     else:
-> 1072         values = convert_listlike(arg._values, format)
   1073         result = arg._constructor(values, index=arg.index, name=arg.name)
   1074 elif isinstance(arg, (ABCDataFrame, abc.MutableMapping)):

File ~\\AppData\\Roaming\\Python\\Python311\\site-packages\\pandas\\core\\tools\\datetimes.py:435, in _convert_listlike_datetimes(arg, format, name, utc, unit, errors, dayfirst, yearfirst, exact)
    433 # `format` could be inferred, or user didn't ask for mixed-format parsing.
    434 if format is not None and format != \"mixed\":
--> 435     return _array_strptime_with_fallback(arg, name, utc, format, exact, errors)
    437 result, tz_parsed = objects_to_datetime64(
    438     arg,
    439     dayfirst=dayfirst,
   (...)    443     allow_object=True,
    444 )
    446 if tz_parsed is not None:
    447     # We can take a shortcut since the datetime64 numpy array
    448     # is in UTC

File ~\\AppData\\Roaming\\Python\\Python311\\site-packages\\pandas\\core\\tools\\datetimes.py:469, in _array_strptime_with_fallback(arg, name, utc, fmt, exact, errors)
    458 def _array_strptime_with_fallback(
    459     arg,
    460     name,
   (...)    464     errors: str,
    465 ) -> Index:
    466     \"\"\"
    467     Call array_strptime, with fallback behavior depending on 'errors'.
    468     \"\"\"
--> 469     result, tz_out = array_strptime(arg, fmt, exact=exact, errors=errors, utc=utc)
    470     if tz_out is not None:
    471         unit = np.datetime_data(result.dtype)[0]

File pandas/_libs/tslibs/strptime.pyx:501, in pandas._libs.tslibs.strptime.array_strptime()

File pandas/_libs/tslibs/strptime.pyx:451, in pandas._libs.tslibs.strptime.array_strptime()

File pandas/_libs/tslibs/strptime.pyx:587, in pandas._libs.tslibs.strptime._parse_with_format()

ValueError: unconverted data remains when parsing with format \"%Y\": \"-01-01\", at position 0. You might want to try:
    - passing `format` if your strings have a consistent format;
    - passing `format='ISO8601'` if your strings are all ISO8601 but not necessarily in exactly the same format;
    - passing `format='mixed'`, and the format will be inferred for each element individually. You might want to use `dayfirst` alongside this."
}
